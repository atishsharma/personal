<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Cordyceps Lab Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            transition: background-color 0.5s;
            touch-action: none;
        }

        /* Overlay Styling */
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid #333;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: 1.1rem;
            color: #4ade80;
        }

        #minBtn {
            background: none;
            border: 1px solid #555;
            color: #aaa;
            cursor: pointer;
            padding: 0 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        #minBtn:hover {
            background: #333;
            color: white;
        }

        #infoContent {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }

        .collapsed #infoContent {
            display: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .color-box {
            width: 12px;
            height: 12px;
            margin-right: 10px;
            border-radius: 2px;
        }

        /* Hamburger Menu & Controls */
        #menu-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        #hamburger {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        #hamburger:hover {
            background: #333;
        }

        #menu-content {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #444;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            gap: 12px;
            min-width: 200px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            transform-origin: top right;
            animation: slideIn 0.2s ease-out;
        }

        #menu-content.open {
            display: flex;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .menu-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: -5px;
        }

        .btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .btn:hover {
            background: #1d4ed8;
        }

        .btn.night {
            background: #7c3aed;
        }

        .btn.night:hover {
            background: #6d28d9;
        }

        .btn.secondary {
            background: #374151;
        }

        .btn.secondary:hover {
            background: #4b5563;
        }

        .btn.undo {
            background: #ea580c;
            opacity: 0.5;
            pointer-events: none;
        }

        .btn.undo.active {
            opacity: 1;
            pointer-events: auto;
        }

        .btn.undo:hover {
            background: #c2410c;
        }

        /* Light Color Controls */
        .light-controls {
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 6px;
            justify-content: center;
        }

        .color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: white;
            box-shadow: 0 0 8px white;
        }

        /* Walk Controls Overlay */
        #walk-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 1rem;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 15;
        }

        #walk-controls span {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #555;
            display: inline-block;
            line-height: 1.6;
        }

        .key {
            border: 1px solid #aaa;
            padding: 2px 6px;
            border-radius: 4px;
            background: #444;
            font-weight: bold;
            font-size: 0.9em;
        }

        /* Mobile Joystick Zone */
        #joystick-zone {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            z-index: 20;
        }

        /* Mobile Elevator Controls */
        #elevator-controls {
            display: none;
            position: absolute;
            bottom: 40px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 20;
        }

        #elevator-controls button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 1.5rem;
            backdrop-filter: blur(4px);
            touch-action: manipulation;
        }

        #elevator-controls button:active {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Mobile Look Zone Tip */
        #mobile-look-tip {
            display: none;
            position: absolute;
            bottom: 120px;
            right: 40px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 15;
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #info {
                top: 10px;
                left: 10px;
                right: 60px;
                max-width: none;
                font-size: 0.8rem;
            }

            #menu-container {
                top: 10px;
                right: 10px;
            }

            .controls {
                display: none;
            }
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            transition: opacity 0.5s;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>

<body>

    <div id="loading">Initializing Walk Mode...</div>

    <div id="info">
        <div class="header-row">
            <h1>Cordyceps Lab</h1>
            <button id="minBtn" onclick="toggleInfo()">-</button>
        </div>
        <div id="infoContent">
            <div class="legend-item">
                <div class="color-box" style="background: #a3a3a3;"></div>Racks (18 units)
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #d97706;"></div>Culture Jars
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #d946ef;"></div>Grow Lights
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #a855f7;"></div>Flow Hood
            </div>
            <hr style="border-color: #444; margin: 8px 0;">
            <p style="font-size: 0.8rem; line-height: 1.4; color: #ccc; margin:0;">
                <strong>Jars on Racks:</strong> ~1,944<br>
                <strong>Table Jars:</strong> 10 units<br>
                <strong>Walls:</strong> 3" Brick (Dual Tone)<br>
                <strong>Table:</strong> Black(Day)/White(Night)
            </p>
        </div>
    </div>

    <div id="menu-container">
        <button id="hamburger" onclick="toggleMenu()">☰</button>
        <div id="menu-content">
            <span class="menu-label">Mode</span>
            <button id="walkBtn" class="btn" style="background: #10b981;" onclick="startWalkthrough()">Enter
                Walkthrough</button>

            <span class="menu-label">Lighting</span>
            <button id="themeBtn" class="btn" onclick="toggleTheme()">Switch to Night Mode</button>

            <span class="menu-label">Grow Spectrum</span>
            <div class="light-controls">
                <button class="color-btn active" style="background: #d946ef;" onclick="setLightColor('purple')"
                    title="Purple"></button>
                <button class="color-btn" style="background: #fcd34d;" onclick="setLightColor('warm')"
                    title="Warm"></button>
                <button class="color-btn" style="background: #e0f2fe;" onclick="setLightColor('cool')"
                    title="Cool"></button>
            </div>

            <span class="menu-label">Visibility</span>
            <button id="clothBtn" class="btn secondary" onclick="toggleCloth()">Blackout Top Row</button>
            <button id="wallBtn" class="btn secondary" onclick="toggleWalls()">Show All Walls</button>
            <button id="undoBtn" class="btn undo" onclick="undoHide()">Undo Hide <span>(0)</span></button>
        </div>
    </div>

    <div id="walk-controls">
        <span>
            <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span>
            Move &nbsp;|&nbsp;
            <span class="key">Q</span> Down <span class="key">E</span> Up &nbsp;|&nbsp;
            Mouse to Look &nbsp;|&nbsp;
            Scroll to Zoom &nbsp;|&nbsp;
            <span class="key">ESC</span> Exit
        </span>
    </div>

    <!-- Mobile Controls -->
    <div id="joystick-zone"></div>
    <div id="elevator-controls" style="display:none;">
        <button id="btnUp">▲</button>
        <button id="btnDown">▼</button>
    </div>
    <div id="mobile-look-tip">Drag to Look</div>

    <div class="controls" id="orbit-controls-text">
        Left Click: Rotate | Right Click: Pan | Scroll: Zoom | Long Press Object: Hide
    </div>

    <!-- Three.js Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <!-- Nipple.js for Virtual Joystick -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        // --- UI LOGIC ---
        let isNight = false;
        let areWallsVisible = false; // Start hidden per request
        let isClothActive = false;
        let currentLightColor = { hex: 0xd946ef, name: 'purple' };
        let isMenuOpen = false;
        let isWalking = false;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        function toggleInfo() {
            const info = document.getElementById('info');
            const btn = document.getElementById('minBtn');
            info.classList.toggle('collapsed');
            btn.textContent = info.classList.contains('collapsed') ? '+' : '-';
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            const menu = document.getElementById('menu-content');
            const btn = document.getElementById('hamburger');
            if (isMenuOpen) {
                menu.classList.add('open');
                btn.textContent = '✕';
            } else {
                menu.classList.remove('open');
                btn.textContent = '☰';
            }
        }

        // --- CONFIGURATION ---
        const ROOM_WIDTH = 22;
        const ROOM_DEPTH = 10;
        const ROOM_HEIGHT = 9;
        const WALL_THICKNESS = 0.25; // 3 inches

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const dayColor = new THREE.Color(0xeeeeee);
        const nightColor = new THREE.Color(0x1a1a1a); // Dark grey, NOT BLACK
        scene.background = dayColor;
        scene.fog = new THREE.Fog(dayColor, 15, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Initial Orbit Position
        const orbitPos = new THREE.Vector3(-18, 20, 22);
        camera.position.copy(orbitPos);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- WALK CONTROLS ---
        const walkControls = new THREE.PointerLockControls(camera, document.body);
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false; // Q
        let moveDown = false; // E

        // Mobile State
        let joystickManager = null;
        let joyForward = 0;
        let joyRight = 0;
        let touchLookStartX = 0;
        let touchLookStartY = 0;
        const lookSpeed = 0.004;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock();
        const WALK_SPEED = 8.0;

        // Start Walkthrough
        window.startWalkthrough = function () {
            isWalking = true;
            toggleMenu();
            // Start at Door: X=-7, Z=-8 (Outside), Look at 0
            camera.position.set(-7, 1.7, -8);
            camera.lookAt(-7, 1.7, 0);

            // Mobile vs Desktop
            if (isMobile) {
                initMobileControls();
                document.getElementById('mobile-look-tip').style.display = 'block';
                document.getElementById('elevator-controls').style.display = 'flex'; // Show Up/Down buttons
                controls.enabled = false;
                // Fix for camera flipping
                camera.rotation.order = "YXZ";
            } else {
                walkControls.lock();
                document.getElementById('walk-controls').style.display = 'block';
                controls.enabled = false;
            }

            document.getElementById('orbit-controls-text').style.display = 'none';
        };

        function initMobileControls() {
            const zone = document.getElementById('joystick-zone');
            zone.style.display = 'block';

            // Touch Listeners for Elevator
            const btnUp = document.getElementById('btnUp');
            const btnDown = document.getElementById('btnDown');

            btnUp.addEventListener('touchstart', (e) => { e.preventDefault(); moveUp = true; });
            btnUp.addEventListener('touchend', (e) => { e.preventDefault(); moveUp = false; });

            btnDown.addEventListener('touchstart', (e) => { e.preventDefault(); moveDown = true; });
            btnDown.addEventListener('touchend', (e) => { e.preventDefault(); moveDown = false; });

            if (joystickManager) return; // Already initialized

            joystickManager = nipplejs.create({
                zone: zone,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 100
            });

            joystickManager.on('move', (evt, data) => {
                const forward = data.vector.y;
                const right = data.vector.x;
                joyForward = forward;
                joyRight = right;
            });

            joystickManager.on('end', () => {
                joyForward = 0;
                joyRight = 0;
            });

            // Touch Look Listeners
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
        }

        let lastTouchX = 0;
        let lastTouchY = 0;

        function onTouchStart(e) {
            // Ignore touches on joystick zone or buttons
            if (e.target.closest('#elevator-controls') || e.target.closest('#joystick-zone')) return;
            // Ignore touches on left half screen roughly if using joystick
            const t = e.touches[0];
            if (t.clientX < window.innerWidth * 0.4 && t.clientY > window.innerHeight * 0.5) return;

            lastTouchX = t.clientX;
            lastTouchY = t.clientY;
        }

        function onTouchMove(e) {
            if (!isWalking) return;
            if (e.target.closest('#elevator-controls') || e.target.closest('#joystick-zone')) return;

            const t = e.touches[0];
            if (t.clientX < window.innerWidth * 0.4 && t.clientY > window.innerHeight * 0.5) return;

            e.preventDefault();

            const deltaX = t.clientX - lastTouchX;
            const deltaY = t.clientY - lastTouchY;

            lastTouchX = t.clientX;
            lastTouchY = t.clientY;

            // Rotate Camera (Inverted Y for natural feel: drag down = look down)
            camera.rotation.y -= deltaX * lookSpeed;
            camera.rotation.x -= deltaY * lookSpeed;

            // Clamp pitch to avoid flipping
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            camera.rotation.z = 0; // Lock roll
        }

        // Event Listeners for Walk Mode (Desktop)
        walkControls.addEventListener('unlock', function () {
            if (!isMobile) {
                isWalking = false;
                document.getElementById('walk-controls').style.display = 'none';
                document.getElementById('orbit-controls-text').style.display = 'block';
                controls.enabled = true;
                camera.fov = 45; camera.updateProjectionMatrix();
                if (camera.position.y < 5) { camera.position.set(-18, 20, 22); camera.lookAt(0, 0, 0); }
            }
        });

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                case 'KeyE': moveUp = true; break;
                case 'KeyQ': moveDown = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
                case 'KeyE': moveUp = false; break;
                case 'KeyQ': moveDown = false; break;
            }
        });

        // Zoom (Scroll)
        document.addEventListener('wheel', (event) => {
            if (isWalking) {
                let fov = camera.fov + event.deltaY * 0.05;
                camera.fov = THREE.MathUtils.clamp(fov, 10, 100);
                camera.updateProjectionMatrix();
            }
        });

        // --- INTERACTION: LONG PRESS TO HIDE ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let pressTimer;
        let isDragging = false;
        const hiddenStack = [];
        const LONG_PRESS_DURATION = 500; // ms

        const walls = [];

        window.addEventListener('pointerdown', (event) => {
            if (event.button !== 0 && !isMobile) return;
            if (isWalking) return;

            isDragging = false;
            pressTimer = setTimeout(() => {
                if (!isDragging) performHide(event.clientX, event.clientY);
            }, LONG_PRESS_DURATION);
        });

        window.addEventListener('pointermove', () => {
            isDragging = true;
            clearTimeout(pressTimer);
        });

        window.addEventListener('pointerup', () => {
            clearTimeout(pressTimer);
        });

        function performHide(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                let parent = target.parent;
                while (parent && parent.type !== 'Scene') {
                    if (parent.userData.isInteractableGroup) {
                        target = parent;
                        break;
                    }
                    parent = parent.parent;
                }
                if (target.visible) {
                    target.visible = false;
                    hiddenStack.push(target);
                    updateUndoBtn();
                }
            }
        }

        function undoHide() {
            if (hiddenStack.length > 0) {
                const obj = hiddenStack.pop();
                obj.visible = true;
                updateUndoBtn();
            }
        }

        function updateUndoBtn() {
            const btn = document.getElementById('undoBtn');
            const count = hiddenStack.length;
            btn.querySelector('span').textContent = `(${count})`;
            if (count > 0) btn.classList.add('active'); else btn.classList.remove('active');
        }

        function toggleWalls() {
            areWallsVisible = !areWallsVisible;
            const btn = document.getElementById('wallBtn');
            walls.forEach(wall => { wall.visible = areWallsVisible; });
            if (areWallsVisible) {
                btn.textContent = "Hide All Walls";
                btn.classList.remove('hidden-walls');
            } else {
                btn.textContent = "Show All Walls";
                btn.classList.add('hidden-walls');
            }
        }

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const prepLight = new THREE.PointLight(0xdbeafe, 0.4, 15);
        prepLight.position.set(-8, 8, 0);
        scene.add(prepLight);

        const rackLights = [];
        const topRowLights = []; // Separate array for blackout row
        const floorLights = [];
        let hoodLight;

        // Table Lamps
        let lampLight1, lampLight2;
        // Sink Light
        let sinkLight;

        // --- MATERIALS ---

        function createCheckerboardTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#cccccc';
            const size = 128;
            for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) if ((x + y) % 2 === 1) ctx.fillRect(x * size, y * size, size, size);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(ROOM_WIDTH / 4, ROOM_DEPTH / 4);
            return tex;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#888888';
            ctx.fillRect(0, 0, 512, 512);
            const rows = 16; const cols = 8;
            const brickH = 512 / rows; const brickW = 512 / cols; const mortar = 4;
            for (let r = 0; r < rows; r++) {
                const offset = (r % 2) * (brickW / 2);
                for (let c = -1; c < cols + 1; c++) {
                    ctx.fillStyle = (r + c) % 2 === 0 ? '#2f3542' : '#222222';
                    const x = c * brickW + offset + mortar / 2;
                    const y = r * brickH + mortar / 2;
                    const w = brickW - mortar; const h = brickH - mortar;
                    ctx.fillRect(x, y, w, h);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(2, 1);
            return tex;
        }

        const wallMat = new THREE.MeshStandardMaterial({ map: createBrickTexture(), side: THREE.DoubleSide, roughness: 0.9, bumpMap: createBrickTexture(), bumpScale: 0.02 });
        const floorMat = new THREE.MeshStandardMaterial({ map: createCheckerboardTexture(), roughness: 0.4 });
        const rackMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.6, roughness: 0.2 });
        const rackLegMat = new THREE.MeshStandardMaterial({ color: 0x475569, metalness: 0.6, roughness: 0.2 });
        const tableMat = new THREE.MeshStandardMaterial({ color: 0xe2e8f0 });
        const workTableMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const hoodMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const sinkMat = new THREE.MeshStandardMaterial({ color: 0x9ca3af, metalness: 0.5 });
        const acMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const fanMat = new THREE.MeshStandardMaterial({ color: 0xef4444, metalness: 0.5 });
        const jarSubstrateMat = new THREE.MeshStandardMaterial({ color: 0xd97706 });
        const jarLidMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const applianceMat = new THREE.MeshStandardMaterial({ color: 0xf1f5f9, metalness: 0.3, roughness: 0.2 });
        const dehydratorMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, metalness: 0.1, roughness: 0.8 });

        const growLightMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: currentLightColor.hex, emissiveIntensity: 0.5 });
        const floorStripMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0 });
        const hoodInteriorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, emissive: 0x00ffff, emissiveIntensity: 0 });
        const glassMat = new THREE.MeshStandardMaterial({ color: 0xa5f3fc, transparent: true, opacity: 0.4, metalness: 0.9, roughness: 0.1 });
        const gloveMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });
        const coatMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });

        // Velvet Cloth Material
        const clothMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 1.0, side: THREE.DoubleSide });

        // --- LIGHT COLOR CONTROLS ---
        window.setLightColor = function (type) {
            const btns = document.querySelectorAll('.color-btn');
            btns.forEach(b => b.classList.remove('active'));
            let hex;
            if (type === 'purple') { hex = 0xd946ef; btns[0].classList.add('active'); }
            else if (type === 'warm') { hex = 0xffaa00; btns[1].classList.add('active'); }
            else if (type === 'cool') { hex = 0xe0f7fa; btns[2].classList.add('active'); }
            currentLightColor = { hex, name: type };

            growLightMat.emissive.setHex(hex);
            rackLights.forEach(light => light.color.setHex(hex));
            topRowLights.forEach(light => light.color.setHex(hex));

            if (lampLight1) lampLight1.color.setHex(hex);
            if (lampLight2) lampLight2.color.setHex(hex);

            toggleTheme(false);
        };

        // --- CLOTH TOGGLE ---
        let clothMesh;
        window.toggleCloth = function () {
            isClothActive = !isClothActive;
            const btn = document.getElementById('clothBtn');

            if (isClothActive) {
                btn.textContent = "Remove Blackout";
                btn.classList.add('hidden-walls'); // reuse active style
                clothMesh.visible = true;
            } else {
                btn.textContent = "Blackout Top Row";
                btn.classList.remove('hidden-walls');
                clothMesh.visible = false;
            }
            toggleTheme(false); // Refresh lights
        };

        // --- THEME TOGGLE FUNCTION ---
        window.toggleTheme = function (shouldToggle = true) {
            if (shouldToggle) isNight = !isNight;
            const btn = document.getElementById('themeBtn');

            if (isNight) {
                btn.textContent = "Switch to Day Mode";
                btn.classList.add('night');
                // Use a Dark Grey background for scene, keeping page dark but not black
                scene.background = nightColor;
                scene.fog.color = nightColor;
                ambientLight.intensity = 0.05;
                sunLight.intensity = 0.05;
                prepLight.intensity = 0.2;

                workTableMat.color.setHex(0xffffff);

                growLightMat.emissiveIntensity = 3.0;

                // Normal Racks
                rackLights.forEach(light => { light.intensity = 0.8; });

                // Top Row (Blackout Logic)
                topRowLights.forEach(light => {
                    light.intensity = isClothActive ? 0 : 0.8;
                });

                floorStripMat.emissiveIntensity = 1.0;
                floorLights.forEach(l => l.intensity = 0.5);
                hoodInteriorMat.emissiveIntensity = 0.8;
                if (hoodLight) hoodLight.intensity = 0.8;
                if (lampLight1) lampLight1.intensity = 2.0;
                if (lampLight2) lampLight2.intensity = 2.0;
                if (sinkLight) sinkLight.intensity = 1.0;

            } else {
                btn.textContent = "Switch to Night Mode";
                btn.classList.remove('night');
                scene.background = dayColor;
                scene.fog.color = dayColor;
                ambientLight.intensity = 0.5;
                sunLight.intensity = 0.8;
                prepLight.intensity = 0.4;

                workTableMat.color.setHex(0x111111);

                growLightMat.emissiveIntensity = 0.8;
                rackLights.forEach(light => { light.intensity = 0; });
                topRowLights.forEach(light => { light.intensity = 0; });

                floorStripMat.emissiveIntensity = 0;
                floorLights.forEach(l => l.intensity = 0);
                hoodInteriorMat.emissiveIntensity = 0;
                if (hoodLight) hoodLight.intensity = 0;
                if (lampLight1) lampLight1.intensity = 0;
                if (lampLight2) lampLight2.intensity = 0;
                if (sinkLight) sinkLight.intensity = 0;
            }
        };

        // --- HELPER FUNCTIONS ---
        function createBox(w, h, d, mat, x, y, z, rotY = 0, shadow = true) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.position.set(x, y + h / 2, z);
            mesh.rotation.y = rotY;
            if (shadow) { mesh.castShadow = true; mesh.receiveShadow = true; }
            scene.add(mesh);
            return mesh;
        }

        function createWall(w, h, d, x, y, z, rotY = 0) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geometry, wallMat);
            mesh.position.set(x, y + h / 2, z);
            mesh.rotation.y = rotY;
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            mesh.visible = areWallsVisible; // Init based on state
            scene.add(mesh);
            walls.push(mesh);
            return mesh;
        }

        // --- BUILDING STRUCTURE ---

        createBox(ROOM_WIDTH, 0.2, ROOM_DEPTH, floorMat, 0, -0.2, 0);

        // Walls
        const shift = WALL_THICKNESS / 2;
        createWall(2.5, ROOM_HEIGHT, WALL_THICKNESS, -9.75, 0, -ROOM_DEPTH / 2 - shift);
        createWall(16.5, ROOM_HEIGHT, WALL_THICKNESS, 2.75, 0, -ROOM_DEPTH / 2 - shift);
        createWall(3, 2, WALL_THICKNESS, -7, 7, -ROOM_DEPTH / 2 - shift);
        createWall(ROOM_WIDTH, ROOM_HEIGHT, WALL_THICKNESS, 0, 0, ROOM_DEPTH / 2 + shift);
        createWall(WALL_THICKNESS, ROOM_HEIGHT, ROOM_DEPTH + (2 * shift), ROOM_WIDTH / 2 + shift, 0, 0);
        createWall(WALL_THICKNESS, ROOM_HEIGHT, ROOM_DEPTH + (2 * shift), -ROOM_WIDTH / 2 - shift, 0, 0);

        // Floor Light Strips
        const stripW = 0.1;
        createBox(ROOM_WIDTH, 0.1, stripW, floorStripMat, 0, 0, -ROOM_DEPTH / 2 + stripW / 2);
        createBox(ROOM_WIDTH, 0.1, stripW, floorStripMat, 0, 0, ROOM_DEPTH / 2 - stripW / 2);
        createBox(stripW, 0.1, ROOM_DEPTH, floorStripMat, -ROOM_WIDTH / 2 + stripW / 2, 0, 0);
        createBox(stripW, 0.1, ROOM_DEPTH, floorStripMat, ROOM_WIDTH / 2 - stripW / 2, 0, 0);
        const fLight = new THREE.PointLight(0x00ffff, 0, 10);
        fLight.position.set(0, 1, 0);
        scene.add(fLight);
        floorLights.push(fLight);


        // --- PREP ROOM EQUIPMENT ---

        // Door
        const doorGroup = new THREE.Group();
        const doorGeo = new THREE.BoxGeometry(0.15, 7, 3);
        const doorMesh = new THREE.Mesh(doorGeo, new THREE.MeshStandardMaterial({ color: 0xffffff }));
        doorMesh.position.set(0, 3.5, 0);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x1e293b });
        const frameL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 7.2, 0.3), frameMat);
        frameL.position.set(0, 3.6, -1.6);
        const frameR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 7.2, 0.3), frameMat);
        frameR.position.set(0, 3.6, 1.6);
        const frameT = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 3.5), frameMat);
        frameT.position.set(0, 7.2, 0);
        const handleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
        const handleMesh = new THREE.Mesh(handleGeo, new THREE.MeshStandardMaterial({ color: 0xc0c0c0 }));
        handleMesh.rotation.x = Math.PI / 2;
        handleMesh.position.set(0.1, 3.5, 1.2);
        const fanHousing = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 3.2), fanMat);
        fanHousing.position.set(0, 7.9, 0);
        doorGroup.add(doorMesh); doorGroup.add(frameL); doorGroup.add(frameR);
        doorGroup.add(frameT); doorGroup.add(handleMesh); doorGroup.add(fanHousing);
        doorGroup.position.set(-7, 0, -5);
        doorGroup.rotation.y = Math.PI / 2;
        scene.add(doorGroup);

        // --- LEFT WALL EQUIPMENT ---

        // Dehydrator
        const dehydrator = new THREE.Mesh(new THREE.BoxGeometry(2.0, 5, 2.0), dehydratorMat);
        dehydrator.position.y = 2.5;
        const dDisplay = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 4), new THREE.MeshStandardMaterial({ color: 0x111827, emissive: 0x1f2937, emissiveIntensity: 0.2 }));
        dDisplay.position.set(0, 2.5, 1.01);
        const dGroup = new THREE.Group();
        dGroup.userData.isInteractableGroup = true;
        dGroup.add(dehydrator);
        const dDispMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 3), new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x059669 }));
        dDispMesh.rotation.y = Math.PI / 2;
        dDispMesh.position.set(1.01, 3, 0);
        dGroup.add(dDispMesh);
        dGroup.position.set(-10, 0, -3.8);
        scene.add(dGroup);

        // Flow Hood
        const hoodGroup = new THREE.Group();
        hoodGroup.userData.isInteractableGroup = true;
        const hTable = new THREE.Mesh(new THREE.BoxGeometry(2.0, 3, 5), tableMat);
        hTable.position.y = 1.5;
        const hBody = new THREE.Mesh(new THREE.BoxGeometry(1.6, 3, 4.8), hoodMat);
        hBody.position.set(-0.1, 4.5, 0);
        const hInterior = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 4.6), hoodInteriorMat);
        hInterior.position.set(0.6, 4.5, 0);

        for (let i = 0; i < 3; i++) {
            const dish = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16), glassMat);
            dish.position.set(0.4, 3.05, -1 + i * 0.4);
            hoodGroup.add(dish);
        }
        const scalpelHandle = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.2), new THREE.MeshStandardMaterial({ color: 0x888888 }));
        scalpelHandle.position.set(0.5, 3.05, 0.5);
        hoodGroup.add(scalpelHandle);

        hoodLight = new THREE.PointLight(0x00ffff, 0, 3);
        hoodLight.position.set(0.5, 4.5, 0);
        hoodGroup.add(hoodLight);

        const hFilter = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 2.5), new THREE.MeshStandardMaterial({ color: 0xe0e7ff, transparent: true, opacity: 0.2 }));
        hFilter.rotation.y = Math.PI / 2;
        hFilter.scale.set(40, 1, 1);
        hFilter.position.set(0.71, 4.5, 0);
        hoodGroup.add(hTable); hoodGroup.add(hBody); hoodGroup.add(hInterior); hoodGroup.add(hFilter);
        hoodGroup.position.set(-10, 0, 0);
        scene.add(hoodGroup);

        // Fridge
        const fridgeGroup = new THREE.Group();
        fridgeGroup.userData.isInteractableGroup = true;
        const fridgeBody = new THREE.Mesh(new THREE.BoxGeometry(2.0, 5, 2.0), applianceMat);
        fridgeBody.position.y = 2.5;
        const fridgeHandle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.1), new THREE.MeshStandardMaterial({ color: 0x94a3b8 }));
        fridgeHandle.position.set(1.0, 2.8, 0.5);
        fridgeGroup.add(fridgeBody); fridgeGroup.add(fridgeHandle);
        fridgeGroup.position.set(-10, 0, 3.8);
        scene.add(fridgeGroup);

        // Sink & Lighting
        const sinkGroup = new THREE.Group();
        sinkGroup.userData.isInteractableGroup = true;
        const sCabinet = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 2), tableMat);
        sCabinet.position.y = 1.5;
        const sBasin = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.5, 1.5), sinkMat);
        sBasin.position.y = 3.25;
        const faucet = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.05, 8, 16, Math.PI), new THREE.MeshStandardMaterial({ color: 0x64748b }));
        faucet.position.set(0, 3.5, -0.5);
        sinkGroup.add(sCabinet); sinkGroup.add(sBasin); sinkGroup.add(faucet);

        sinkLight = new THREE.SpotLight(0xffffff, 0);
        sinkLight.position.set(0, 5, 0);
        sinkLight.target.position.set(0, 3, 0);
        sinkLight.angle = 0.5; sinkLight.penumbra = 0.5;
        sinkGroup.add(sinkLight); sinkGroup.add(sinkLight.target);

        sinkGroup.position.set(-6, 0, 4);
        scene.add(sinkGroup);

        // Wall Coat Rack
        const rackGroup = new THREE.Group();
        rackGroup.userData.isInteractableGroup = true;
        const rBar = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 3, 8), new THREE.MeshStandardMaterial({ color: 0x888888 }));
        rBar.rotation.z = Math.PI / 2;
        const b1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0x333333 })); b1.position.set(-1.4, 0, -0.15);
        const b2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0x333333 })); b2.position.set(1.4, 0, -0.15);
        rackGroup.add(rBar); rackGroup.add(b1); rackGroup.add(b2);

        const hangerMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const makeHangingCoat = (x) => {
            const g = new THREE.Group();
            const hook = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.01, 8, 16, Math.PI), hangerMat);
            hook.position.y = 0.1;
            const shoulder = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.1), coatMat);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.1), coatMat);
            body.position.y = -0.6;
            g.add(hook); g.add(shoulder); g.add(body);
            g.position.set(x, -0.1, 0);
            return g;
        }
        rackGroup.add(makeHangingCoat(-0.5));
        rackGroup.add(makeHangingCoat(0.5));
        rackGroup.position.set(-6, 6, 4.8);
        scene.add(rackGroup);

        // Autoclave
        createBox(2.5, 3, 3, tableMat, -6.5, 0, 0);
        const autoClave = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 1.2, 16), new THREE.MeshStandardMaterial({ color: 0xcbd5e1, metalness: 0.8, roughness: 0.2 }));
        autoClave.rotation.z = Math.PI / 2;
        autoClave.position.set(-6.5, 3.6, 0.5);
        scene.add(autoClave);

        // Work Table
        const storageGroup = new THREE.Group();
        storageGroup.userData.isInteractableGroup = true;
        const tableTop = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 2.5), workTableMat);
        tableTop.position.y = 3;
        const legGeo = new THREE.BoxGeometry(0.2, 3, 0.2);
        const leg1 = new THREE.Mesh(legGeo, workTableMat); leg1.position.set(-1.8, 1.5, -1.1);
        const leg2 = new THREE.Mesh(legGeo, workTableMat); leg2.position.set(1.8, 1.5, -1.1);
        const leg3 = new THREE.Mesh(legGeo, workTableMat); leg3.position.set(-1.8, 1.5, 1.1);
        const leg4 = new THREE.Mesh(legGeo, workTableMat); leg4.position.set(1.8, 1.5, 1.1);
        const tableShelf1 = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.1, 2.3), new THREE.MeshStandardMaterial({ color: 0xcbd5e1 }));
        tableShelf1.position.y = 1;
        const tableShelf2 = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.1, 2.3), new THREE.MeshStandardMaterial({ color: 0xcbd5e1 }));
        tableShelf2.position.y = 2;

        // Props
        const beaker1 = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.4, 16), glassMat);
        beaker1.position.set(-1, 3.2, 0.5);
        const beaker2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16), glassMat);
        beaker2.position.set(-0.7, 3.15, 0.6);
        const glove1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), gloveMat);
        glove1.scale.set(1, 0.2, 1.5);
        glove1.position.set(0, 3.05, 0.5);
        const glove2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), gloveMat);
        glove2.scale.set(1, 0.2, 1.5);
        glove2.position.set(0.3, 3.05, 0.6);
        glove2.rotation.y = 0.5;

        // Table Lamps
        function createLamp(x, z) {
            const g = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.05, 32), new THREE.MeshStandardMaterial({ color: 0x333333 })); base.position.y = 0.025;
            const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8), new THREE.MeshStandardMaterial({ color: 0x333333 })); stand.position.set(0, 0.3, 0);
            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.3, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide }));
            shade.position.set(0, 0.6, 0.1); shade.rotation.x = Math.PI / 4;
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff })); bulb.position.set(0, 0.55, 0.15);
            g.add(base); g.add(stand); g.add(shade); g.add(bulb);

            const light = new THREE.SpotLight(currentLightColor.hex, 0);
            light.position.set(0, 0.55, 0.15);
            light.target.position.set(0, 0, 0.5);
            light.angle = 0.8; light.penumbra = 0.5; light.distance = 5; light.decay = 2;
            g.add(light); g.add(light.target);

            g.position.set(x, 3.1, z);
            g.rotation.y = (z > 0) ? Math.PI : 0;
            return { group: g, light: light };
        }

        const l1 = createLamp(-1.5, 0.8);
        lampLight1 = l1.light;
        storageGroup.add(l1.group);

        const l2 = createLamp(1.5, 0.8);
        lampLight2 = l2.light;
        storageGroup.add(l2.group);

        // 10 Jars
        const tableJarGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.3, 10);
        for (let i = 0; i < 10; i++) {
            const tJar = new THREE.Mesh(tableJarGeo, jarSubstrateMat);
            const tLid = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.05, 10), jarLidMat);
            tLid.position.y = 0.175;
            tJar.add(tLid);
            const col = i % 5;
            const row = Math.floor(i / 5);
            tJar.position.set(-1.2 + (col * 0.4), 3.15, -0.6 + (row * 0.4));
            storageGroup.add(tJar);
        }

        storageGroup.add(tableTop); storageGroup.add(leg1); storageGroup.add(leg2);
        storageGroup.add(leg3); storageGroup.add(leg4);
        storageGroup.add(tableShelf1); storageGroup.add(tableShelf2);
        storageGroup.add(beaker1); storageGroup.add(beaker2);
        storageGroup.add(glove1); storageGroup.add(glove2);
        storageGroup.add(l1.group);
        storageGroup.add(l2.group);

        storageGroup.position.set(-1.6, 0, 0);
        scene.add(storageGroup);

        // --- GROW AREA RACKS ---

        const jarGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.3, 10);
        const jarMat = jarSubstrateMat;
        const jarCount = 2100;
        const jarMesh = new THREE.InstancedMesh(jarGeo, jarMat, jarCount);
        jarMesh.castShadow = true;
        scene.add(jarMesh);
        const lidGeo = new THREE.CylinderGeometry(0.10, 0.10, 0.05, 10);
        const lidMesh = new THREE.InstancedMesh(lidGeo, jarLidMat, jarCount);
        scene.add(lidMesh);

        let jarIndex = 0;
        const dummy = new THREE.Object3D();

        function addJarsToShelf(x, y, z, width, depth, rotY = 0) {
            const rows = 3; const cols = 6;
            const spacingX = width / cols;
            const spacingZ = depth / rows;
            const localStartX = -width / 2 + (spacingX / 2);
            const localStartZ = -depth / 2 + (spacingZ / 2);

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (jarIndex >= jarCount) return;
                    const lx = localStartX + (c * spacingX);
                    const lz = localStartZ + (r * spacingZ);
                    const rx = lx * Math.cos(rotY) - lz * Math.sin(rotY);
                    const rz = lx * Math.sin(rotY) + lz * Math.cos(rotY);
                    const jX = x + rx;
                    const jZ = z + rz;

                    dummy.position.set(jX, y + 0.15, jZ);
                    dummy.updateMatrix();
                    jarMesh.setMatrixAt(jarIndex, dummy.matrix);

                    dummy.position.set(jX, y + 0.32, jZ);
                    dummy.updateMatrix();
                    lidMesh.setMatrixAt(jarIndex, dummy.matrix);

                    jarIndex++;
                }
            }
        }

        function createRack(x, z, rotY = 0, isTopRow = false) {
            const group = new THREE.Group();
            group.userData.isInteractableGroup = true;
            const w = 2, h = 6, d = 1;

            for (let i = 0; i < 6; i++) {
                const shelfY = (i * 1) + 0.5;
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(w, 0.05, d), rackMat);
                shelf.position.y = shelfY;
                shelf.castShadow = true;
                group.add(shelf);

                const lightStrip = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, 0.02, 0.05), growLightMat);
                lightStrip.position.y = shelfY - 0.035;
                group.add(lightStrip);
            }

            const topLightStrip = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, 0.02, 0.05), growLightMat);
            topLightStrip.position.y = 6.0;
            group.add(topLightStrip);

            const rackLight = new THREE.PointLight(currentLightColor.hex, 0, 4);
            rackLight.position.set(0, 3, 0);
            group.add(rackLight);

            if (isTopRow) {
                topRowLights.push(rackLight);
            } else {
                rackLights.push(rackLight);
            }

            addJarsToShelf(x, 0.5, z, w, d, rotY);
            for (let i = 1; i < 6; i++) addJarsToShelf(x, i + 0.5, z, w, d, rotY);

            const postGeo = new THREE.BoxGeometry(0.05, h, 0.05);
            const positions = [[-w / 2, d / 2], [w / 2, d / 2], [-w / 2, -d / 2], [w / 2, -d / 2]];
            positions.forEach(pos => {
                const post = new THREE.Mesh(postGeo, rackLegMat);
                post.position.set(pos[0], h / 2, pos[1]);
                group.add(post);
            });

            group.position.set(x, 0, z);
            group.rotation.y = rotY;
            scene.add(group);
        }

        const rackStartX = -3;
        const rackSpacing = 2.2;

        for (let i = 0; i < 6; i++) createRack(rackStartX + (i * rackSpacing), -3.8, 0, true);
        for (let i = 0; i < 6; i++) createRack(rackStartX + (i * rackSpacing), 3.8);
        for (let i = 2; i < 4; i++) {
            const xPos = rackStartX + (i * rackSpacing);
            createRack(xPos, -0.6);
            createRack(xPos, 0.6);
        }
        createRack(10.5, -1.5, Math.PI / 2);
        createRack(10.5, 1.5, Math.PI / 2);

        // BLACKOUT CLOTH
        clothMesh = new THREE.Mesh(
            new THREE.BoxGeometry(13.2, 6.1, 1.2),
            clothMat
        );
        clothMesh.position.set(2.5, 3.05, -3.8);
        clothMesh.visible = false;
        scene.add(clothMesh);

        const acGroup = new THREE.Group();
        acGroup.userData.isInteractableGroup = true;
        const acBody = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 3.5), acMat);
        acBody.castShadow = true;
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 3), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        vent.position.x = -0.46;
        acGroup.add(acBody); acGroup.add(vent);
        acGroup.position.set(10.5, 7, 0);
        scene.add(acGroup);

        const humGroup = new THREE.Group();
        humGroup.userData.isInteractableGroup = true;
        const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        tank.position.y = 0.75;
        const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        pipe.position.set(0, 2, 0);
        const cap = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.2, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        cap.position.set(0, 2.5, 0);
        humGroup.add(tank); humGroup.add(pipe); humGroup.add(cap);
        humGroup.position.set(6, 0, 0);
        scene.add(humGroup);

        jarMesh.instanceMatrix.needsUpdate = true;
        lidMesh.instanceMatrix.needsUpdate = true;

        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => document.getElementById('loading').remove(), 500);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (isWalking) {
                // Determine input vector
                let inputX = 0;
                let inputZ = 0;

                if (isMobile) {
                    // Mobile Joystick input
                    inputZ = -joyForward * 2.0; // Invert logic for standard forward/back feel if needed
                    inputX = -joyRight * 2.0;
                } else {
                    // Desktop Keyboard input
                    inputZ = Number(moveForward) - Number(moveBackward);
                    inputX = Number(moveRight) - Number(moveLeft);
                }

                // Damping / Friction
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = inputZ;
                direction.x = inputX;
                direction.normalize(); // Normalize prevents faster diagonal movement if using keyboard (joystick handles its own)

                // If user is inputting movement, accelerate
                if (inputZ !== 0 || inputX !== 0) {
                    // Apply movement speed
                    // Note: PointerLockControls 'moveForward' takes a distance, not speed
                    // But here we are manipulating velocity for smoothness
                    if (isMobile) {
                        // On mobile, joystick is analog, so we can multiply by strength
                        // For now, simple normalized direction * speed
                        velocity.z -= direction.z * WALK_SPEED * delta;
                        velocity.x -= direction.x * WALK_SPEED * delta;
                    } else {
                        if (moveForward || moveBackward) velocity.z -= direction.z * WALK_SPEED * delta;
                        if (moveLeft || moveRight) velocity.x -= direction.x * WALK_SPEED * delta;
                    }
                }

                // Apply velocity to camera
                if (isMobile) {
                    // Manual movement based on camera direction
                    // Get camera forward vector (projected on XZ plane)
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    camDir.y = 0;
                    camDir.normalize();

                    const camRight = new THREE.Vector3();
                    camRight.crossVectors(camera.up, camDir).normalize();

                    // Note: In our coordinate system, 'Forward' usually means -Z relative to camera look
                    // joystick Y>0 means forward.

                    // We need to translate velocity.z (forward/back) and velocity.x (strafe) into world coords
                    // velocity.z < 0 is forward
                    // velocity.x < 0 is right

                    const moveVec = new THREE.Vector3();
                    moveVec.addScaledVector(camDir, -velocity.z * delta); // Forward
                    moveVec.addScaledVector(camRight, velocity.x * delta); // Right strafe (PointerLock moves right with positive)

                    camera.position.add(moveVec);
                } else {
                    // PointerLockControls handles direction internally
                    walkControls.moveRight(-velocity.x * delta);
                    walkControls.moveForward(-velocity.z * delta);
                }

                // Vertical (Elevator)
                if (moveUp) camera.position.y += WALK_SPEED * delta;
                if (moveDown) camera.position.y -= WALK_SPEED * delta;

                // Keep inside room (Buffer)
                const pos = camera.position;
                if (pos.x < -10.5) pos.x = -10.5;
                if (pos.x > 10.5) pos.x = 10.5;
                if (pos.z < -4.5) pos.z = -4.5;
                if (pos.z > 4.5) pos.z = 4.5;
                if (pos.y < 0.5) pos.y = 0.5;
                if (pos.y > 8.5) pos.y = 8.5;
            } else {
                controls.update();
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>